# Тестовое задание газпром
Работа выполнена в master ветке

# Основные ошибки с которыми столкнулся и их решения:

## Библиотека poi - ooxml не работает в модуле core.
Так как тестовый файл был дан в расширении .xlsx то сразу было принято решение использовать библиотеку poi и находящиеся в ней классы XSSF для обработки данного формата.
Изначально задумка была в том, чтобы с клиентского слоя передавать inputStream данных в сервисный метод, где бы уже происходил парсинг файла. Однако, данная библиотека, хоть и присутствует по дефолту в cuba platform, категорически отказывается работать в middleware слое. Были предприняты различные способы импорта различных версий библиотек, а также добавление их в различные слои, однако ничего не помогло. При этом аналогичная ей библиотека poi, содержащая классы HSSF для обработки .xls формата отлично импортится в core модуле. Таким образом, было принято решение оставить парсинг файла на клиентском слое, где библиотека poi-ooxml прекрасно работает, а уже сохранение данных вынести в сервисный слой.

## Инициализация XSSFWorkbook тратит много памяти.
Изначально был предпринят стандартный способ обработки excel файла с помощью инициализации обьекта Workbook с помощью Workbook workbook = new XSSFWorkbook(inputStream). Однако, данный способ в процессе тратит большое количество памяти и конкретно на моем устройстве с тестовым файлом по итогу не заканчивал создание и падал с outOfMemory. Было найдено решение использовать xmlreader, который позволил не только снизить потребление памяти и обработать тестовый файл, но и сделать это эффективно по времени. Из недостатков данный способ чуть сложнее в реализации и менее гибкий.

## Длительное время сохранения сущностей в бд.
Изначально была предпринята попытка создания листа сущностей на основе полученных данных и затем сохранением всех их с помощью одного коммита dataManager.commit(new CommitContext(list)), однако данных способ занимал огромное количество времени(>30m). Тогда было принято решение комитить сущности по отдельности а также распараллелить этот процесс. Также был сделан выбор в пользу EntityManagera, который по сравнению с аналогичной реализации на dataManager, показал результаты лучше в 1.5 раза. Из недостатков, если создавать транзакцию до распараллеливания, то в некоторых потоках она отстуствует, поэтому пришлось для каждого элемента открывать, комитить и закрывать транзакции. Несмотря на это способ показал себя максимально эффективно и выполнялся на моем устройстве на тестовом файле примерно за 2 минуты.

# Что было реализовано
Кроме указанных ранее алгоритмов, также был реализован фоновый импорт файла, чтобы не блокировать пользовательских интерфейс, обработаны основные ошибки, такие как неправильное расширение файла, некорректный стандарт разметки файла, то есть несоответствие 1ой строки(то есть если файл не содержал такую же первую строку как в тестовом файле, то это рассматривалось как показатель того что пользователь мог подать неправильные данные, либо же направильно их расположить в таблице) и остутсвие строк данных после правильной 1ой строки, некорректные id, либо незаполненные поля. Также была добавлена локализация(англ, рус) и уведомления по окончанию работы алгоритма с результатами(ошибка, импорт успешен, либо импорт успешен не полностью, в случае если были корректные строки и некорректные). Также по заданию была реализована возможность загрузки номенклатур котоыре уже содержатся в бд, то есть они будут обновлены.

# Недостатки работы
Во первых, все таки хотелось бы корректнее расположить код, то есть парсинг в сервисе, а работу с данными в бине например.
Во вторых, возможно не все ошибки обработаны
В третьих, возможно корректнее делать коммит 1ой транзакцией, но здесь просто сделал уклон в эффективность, а не безопасность.
В четвертых, возможно следует сделать отмену процесса импорта, но это я бы делал в случае если бы реализовал коммит в 1 транзакцию, а так получается при отмене у нас часть файла в бд сохранится, а часть нет.
В пятых, реализация сильно зависит от определенной разметки файла и не очень приветлива к расширению сущности номенклатура, но в целом это вполне реально

По затрачиваему времени и памяти на мой взгляд эта реализация работает оптимально.
